{"version":3,"file":"coffeescript.min.js","sources":["../../../../src/codemirror/mode/coffeescript/coffeescript.js"],"sourcesContent":["/*eslint-disable*/\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\n(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../../lib/codemirror\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../../lib/codemirror\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"coffeescript\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\n    var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n    var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n    var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\n    var wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                    \"is\", \"isnt\", \"in\",\n                                    \"instanceof\", \"typeof\"]);\n    var indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                          \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\n    var commonKeywords = [\"map\",\"plot\", \"integrate\",\"diff\",\"makelist\",\"lmin\",\"lmax\",\"realroots\",\"append\", \"rand\", \"rand_with_step\", \"random_permutation\", \"rand_with_prohib\", \"max\",\"min\", \"continue\", \"break\", \"by\", \"debugger\", \"delete\",\n                          \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                          \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\n    var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n    indentKeywords = wordRegexp(indentKeywords);\n\n\n    var stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\n    var regexPrefixes = /^(\\/{3}|\\/)/;\n    var commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\n    var constants = wordRegexp(commonConstants);\n\n    // Tokenizers\n    function tokenBase(stream, state) {\n      // Handle scope changes\n      if (stream.sol()) {\n        if (state.scope.align === null) state.scope.align = false;\n        var scopeOffset = state.scope.offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n            return \"indent\";\n          } else if (lineOffset < scopeOffset) {\n            return \"dedent\";\n          }\n          return null;\n        } else {\n          if (scopeOffset > 0) {\n            dedent(stream, state);\n          }\n        }\n      }\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var ch = stream.peek();\n\n      // Handle docco title comment (single line)\n      if (stream.match(\"####\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Handle multi line comments\n      if (stream.match(\"###\")) {\n        state.tokenize = longComment;\n        return state.tokenize(stream, state);\n      }\n\n      // Single line comment\n      if (ch === \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Handle number literals\n      if (stream.match(/^-?[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n          floatLiteral = true;\n        }\n        if (stream.match(/^-?\\d+\\.\\d*/)) {\n          floatLiteral = true;\n        }\n        if (stream.match(/^-?\\.\\d+/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // prevent from getting extra . on 1..\n          if (stream.peek() == \".\"){\n            stream.backUp(1);\n          }\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^-?0x[0-9a-f]+/i)) {\n          intLiteral = true;\n        }\n        // Decimal\n        if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^-?0(?![\\dx])/i)) {\n          intLiteral = true;\n        }\n        if (intLiteral) {\n          return \"number\";\n        }\n      }\n\n      // Handle strings\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenFactory(stream.current(), false, \"string\");\n        return state.tokenize(stream, state);\n      }\n      // Handle regex literals\n      if (stream.match(regexPrefixes)) {\n        if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n          state.tokenize = tokenFactory(stream.current(), true, \"string-2\");\n          return state.tokenize(stream, state);\n        } else {\n          stream.backUp(1);\n        }\n      }\n\n\n\n      // Handle operators and delimiters\n      if (stream.match(operators) || stream.match(wordOperators)) {\n        return \"operator\";\n      }\n      if (stream.match(delimiters)) {\n        return \"punctuation\";\n      }\n\n      if (stream.match(constants)) {\n        return \"atom\";\n      }\n\n      if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n        return \"property\";\n      }\n\n      if (stream.match(keywords)) {\n        return \"keyword\";\n      }\n\n      if (stream.match(identifiers)) {\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function tokenFactory(delimiter, singleline, outclass) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\/\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol()) {\n              return outclass;\n            }\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            return outclass;\n          } else {\n            stream.eat(/['\"\\/]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) {\n            outclass = ERRORCLASS;\n          } else {\n            state.tokenize = tokenBase;\n          }\n        }\n        return outclass;\n      };\n    }\n\n    function longComment(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^#]/);\n        if (stream.match(\"###\")) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        stream.eatWhile(\"#\");\n      }\n      return \"comment\";\n    }\n\n    function indent(stream, state, type) {\n      type = type || \"coffee\";\n      var offset = 0, align = false, alignOffset = null;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (scope.type === \"coffee\" || scope.type == \"}\") {\n          offset = scope.offset + conf.indentUnit;\n          break;\n        }\n      }\n      if (type !== \"coffee\") {\n        align = null;\n        alignOffset = stream.column() + stream.current().length;\n      } else if (state.scope.align) {\n        state.scope.align = false;\n      }\n      state.scope = {\n        offset: offset,\n        type: type,\n        prev: state.scope,\n        align: align,\n        alignOffset: alignOffset\n      };\n    }\n\n    function dedent(stream, state) {\n      if (!state.scope.prev) return;\n      if (state.scope.type === \"coffee\") {\n        var _indent = stream.indentation();\n        var matched = false;\n        for (var scope = state.scope; scope; scope = scope.prev) {\n          if (_indent === scope.offset) {\n            matched = true;\n            break;\n          }\n        }\n        if (!matched) {\n          return true;\n        }\n        while (state.scope.prev && state.scope.offset !== _indent) {\n          state.scope = state.scope.prev;\n        }\n        return false;\n      } else {\n        state.scope = state.scope.prev;\n        return false;\n      }\n    }\n\n    function tokenLexer(stream, state) {\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle scope changes.\n      if (current === \"return\") {\n        state.dedent = true;\n      }\n      if (((current === \"->\" || current === \"=>\") && stream.eol())\n          || style === \"indent\") {\n        indent(stream, state);\n      }\n      var delimiter_index = \"[({\".indexOf(current);\n      if (delimiter_index !== -1) {\n        indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n      }\n      if (indentKeywords.exec(current)){\n        indent(stream, state);\n      }\n      if (current == \"then\"){\n        dedent(stream, state);\n      }\n\n\n      if (style === \"dedent\") {\n        if (dedent(stream, state)) {\n          return ERRORCLASS;\n        }\n      }\n      delimiter_index = \"])}\".indexOf(current);\n      if (delimiter_index !== -1) {\n        while (state.scope.type == \"coffee\" && state.scope.prev)\n          state.scope = state.scope.prev;\n        if (state.scope.type == current)\n          state.scope = state.scope.prev;\n      }\n      if (state.dedent && stream.eol()) {\n        if (state.scope.type == \"coffee\" && state.scope.prev)\n          state.scope = state.scope.prev;\n        state.dedent = false;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scope: {offset:basecolumn || 0, type:\"coffee\", prev: null, align: false},\n          prop: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var fillAlign = state.scope.align === null && state.scope;\n        if (fillAlign && stream.sol()) fillAlign.align = false;\n\n        var style = tokenLexer(stream, state);\n        if (style && style != \"comment\") {\n          if (fillAlign) fillAlign.align = true;\n          state.prop = style == \"punctuation\" && stream.current() == \".\"\n        }\n\n        return style;\n      },\n\n      indent: function(state, text) {\n        if (state.tokenize != tokenBase) return 0;\n        var scope = state.scope;\n        var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n        if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n        var closes = closer && scope.type === text.charAt(0);\n        if (scope.align)\n          return scope.alignOffset - (closes ? 1 : 0);\n        else\n          return (closes ? scope.prev : scope).offset;\n      },\n\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  // IANA registered media type\n  // https://www.iana.org/assignments/media-types/\n  CodeMirror.defineMIME(\"application/vnd.coffeescript\", \"coffeescript\");\n\n  CodeMirror.defineMIME(\"text/x-coffeescript\", \"coffeescript\");\n  CodeMirror.defineMIME(\"text/coffeescript\", \"coffeescript\");\n\n  });\n"],"names":["mod","CodeMirror","defineMode","conf","parserConf","wordRegexp","words","RegExp","join","operators","delimiters","identifiers","atProp","wordOperators","indentKeywords","keywords","concat","stringPrefixes","regexPrefixes","constants","tokenBase","stream","state","sol","scope","align","scopeOffset","offset","eatSpace","lineOffset","indentation","type","dedent","ch","peek","match","skipToEnd","tokenize","longComment","floatLiteral","backUp","intLiteral","tokenFactory","current","prop","next","delimiter","singleline","outclass","eol","eatWhile","eat","singleLineStringErrors","indent","alignOffset","prev","indentUnit","column","length","_indent","matched","startState","basecolumn","token","fillAlign","style","delimiter_index","indexOf","slice","exec","tokenLexer","text","closer","charAt","closes","lineComment","fold","defineMIME","exports","module","require","define","amd"],"mappings":"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"}